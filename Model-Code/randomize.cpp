//******************************************
//Implementation file for randomize.h
//This file is for Sun
//*****************************************

#include <stdlib.h>
#include <iostream>
#include <time.h>
#include <math.h>
#include "randomize.h"

//Initializes the array that erand48 works with
void initialize(Xsubi_array& xsubi)
{
//setting the seed value from time	
	long seed;
	seed = ((long)time(NULL))%100000;
	srand48(seed);
//the above method gives a five digit seed
//it is further randomized to ensure better distribution 
	seed = lrand48();
	srand48(seed);
//initializing the array for the randomizing functions	
	for (int i = 0; i < 3; i++)
	{
		xsubi[i] = (short)lrand48();
	}
}

//returns a random number from the sequence
//initialized by the function avbove
//the value is (0.0,1.0)
double unit_random(Xsubi_array& xsubi)
{
	double rand_no;
	rand_no = erand48(xsubi);
//the following is necessary as the random number 
//generated by erand48 is [0.0,1.0)
//this may cause problems for transformations
	while(rand_no == 0.0)
	{
		rand_no = erand48(xsubi);
	}
	return rand_no;
}

double uniform_random(double min, double max, Xsubi_array& xsubi)
{
	double rand_no;
	rand_no = min + (max - min)*unit_random(xsubi);
	return rand_no;
}

//returns a random double calculated from a two random variables
//from unit distribution
double stdNormal(Xsubi_array& xsubi)
{
        double u_rand1, u_rand2, norm_rand, temp;
        u_rand1 = erand48(xsubi);
        u_rand2 = erand48(xsubi);
//now transform to a N(0,1)
        temp = (-2.0)*log(u_rand1);
        temp = sqrt(temp);
	norm_rand = temp*cos(2.0*M_PI*u_rand2);
	return norm_rand;
}

double normal_random(double mean, double std_dev, Xsubi_array& xsubi)
{
	double norm_rand;
	norm_rand = stdNormal(xsubi);
//convert it to N(mean, std_dev)
	norm_rand = norm_rand*std_dev + mean;
	return norm_rand;
}

//get p normal for x with mean and sd
double p_norm(double x, double mu, double sd)
{
	double exponent;
	double factor;
	double p;
	exponent = -(x - mu)*(x - mu)/(2.0*sd*sd);
	factor = 1.0/(sqrt(2.0*M_PI)*sd);
	p = factor*exp(exponent);
	return p;
}

void stdNormal(double* stdNvect, int ndim, Xsubi_array& xsubi)
{
	for(int i = 0; i < ndim; i++)
	{
		stdNvect[i] = stdNormal(xsubi);
	}
}

void corNormal(double* corNvect, double* stdNvect, double** CholeskyF, int ndim, Xsubi_array& xsubi)
{
	double tdbl;
	stdNormal(stdNvect, ndim, xsubi);
	for (int i = 0; i < ndim; i++)
	{
		tdbl=0.0;
		for (int j = 0; j < ndim; j++)
		{
			tdbl += CholeskyF[i][j]*stdNvect[j];
		}
		corNvect[i] = tdbl;
	}
}

void corNormal(double* corNvect, double* stdNvect, double* meanvect, double** CholeskyF, 
								int ndim, Xsubi_array& xsubi)
{
	corNormal(corNvect, stdNvect, CholeskyF, ndim, xsubi);
	for (int i = 0; i < ndim; i++)
	{
		corNvect[i] += meanvect[i];
	}
}

//get gamma p-value
double p_gamma(double theta, double alpha, double beta)
{
	double p;
	double g_alpha, lg_alpha;
	double fac1, fac2, fac3;
	if(theta < 0 || alpha <= 0 || beta <= 0)
	{
		std::cerr << "Error in input values!";
		p = 0.0;
	}
	else
	{
		if(theta == 0.0)
		{
			p = 0.0;
		}
		else
		{
			lg_alpha = lgamma(alpha);
			g_alpha = signgam*exp(lg_alpha);
			fac1 = pow(beta, alpha)/g_alpha;
			fac2 = pow(theta, (alpha - 1.0));
			fac3 = -1.0*beta*theta;
			fac3 = expm1(fac3) + 1.0;
			p = fac1*fac2*fac3;
		}
	}
	return p;
}

//given a p-value and parameters and interval (accuracy), get the value of theta
double val_gamma(double accuracy, double p_val, double alpha, double beta)
{
	double theta;
	double p_temp = 0.0;
	double temp;
	int theta_temp;
	double interval = 0.1*accuracy; //one decimal place higher

//get the value of theta accurate to the next decemal place
	theta = 0.0;
	while(p_temp < p_val)
	{
		theta += interval;
		temp = p_gamma(theta, alpha, beta)*interval;
		p_temp += temp;
	}
//round theta to required accuracy
	theta = 0.5 + (theta/accuracy);
	theta_temp = theta;
	theta = (double)theta_temp*accuracy;

	return theta;
}

//inv gamma p-value
double p_invgamma(double theta, double alpha, double beta)
{
        double p;
        double g_alpha, lg_alpha;
        double fac1, fac2, fac3;
        if(theta <= 0 || alpha <= 0 || beta <= 0)
        {
                std::cerr << "Error in input values!";
                p = 0.0;
        }
        else
        {
                lg_alpha = lgamma(alpha);
                g_alpha = signgam*exp(lg_alpha);
                fac1 = pow(beta, alpha)/g_alpha;
                fac2 = pow(theta, -(alpha + 1.0));
                fac3 = -1.0*beta/theta;
                fac3 = expm1(fac3) + 1.0;
                p = fac1*fac2*fac3;
        }
        return p;
}

